<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Nicolas Gong"><title>Managing Python Projects ï½œ nicolgo</title><meta name=description content="Introduction The article is the summary of this course.
We need some structure to work together effectively.
A good process can help us avoid mistakes. Here are some steps:
Automation: machines are less prone to make mistakes than humans. Checklists: Checklists contains best practices and eliminated error that comes from forgetting things. which can refer &amp;ldquo;The Checklist Manifesto&amp;rdquo; Knowledge transfer We can pack and reuse this code in other projects by writing code in an established way.
Directory Structure Overview Here&amp;rsquo;s a folder structure for a python project:
project/ |- src/ | |- __init__.py | |- project.py |- test/ | |- test_project."><meta name=keywords content="Python,software"><link rel="shortcut icon" href=https://nicolgo.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://nicolgo.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://nicolgo.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://nicolgo.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://nicolgo.github.io/><span>nicolgo</span></a></h1></div><div class=description><p class=sub_title>Lifelong learning</p><div class=my_socials><a href=https://github.com/nicolgo title=github target=_blank><i class=ri-github-fill></i></a>
<a href=https://twitter.com/NicolasGong title=twitter target=_blank><i class=ri-twitter-fill></i></a>
<a href=https://nicolgo.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/managing-python-projects/>Managing Python Projects</a></h2><span class=date>2022.06.09</span></div><div class="post_content markdown"><h2 id=introduction>Introduction</h2><p>The article is the summary of this <a href="https://www.linkedin.com/learning/managing-python-projects/managing-python-day-to-day?autoplay=true">course</a>.</p><p>We need some structure to work together effectively.</p><p>A good process can help us avoid mistakes. Here are some steps:</p><ul><li>Automation: machines are less prone to make mistakes than humans.</li><li>Checklists: Checklists contains best practices and eliminated error that comes from forgetting things. which can refer &ldquo;The Checklist Manifesto&rdquo;</li><li>Knowledge transfer</li></ul><p>We can pack and reuse this code in other projects by writing code in an established way.</p><h2 id=directory-structure>Directory Structure</h2><h3 id=overview>Overview</h3><p>Here&rsquo;s a folder structure for a python project:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>project/
</span></span><span class=line><span class=cl>|- src/
</span></span><span class=line><span class=cl>|  |- __init__.py
</span></span><span class=line><span class=cl>|  |- project.py
</span></span><span class=line><span class=cl>|- test/
</span></span><span class=line><span class=cl>|  |- test_project.py
</span></span><span class=line><span class=cl>|- LICENSE.txt
</span></span><span class=line><span class=cl>|- Makefile
</span></span><span class=line><span class=cl>|- README.md
</span></span><span class=line><span class=cl>|- requirements-dev.txt
</span></span><span class=line><span class=cl>|- requirements.txt
</span></span><span class=line><span class=cl>|- setup.py
</span></span></code></pre></div><p>The details can be seen <a href=https://github.com/353solutions/nlpy>here</a></p><h3 id=readmemd>README.md</h3><p>For a project, it is very common that write ReadMe in Markdown format to provide information about the project. It should include these:</p><ul><li>short description of your project</li><li>how to use it with examples</li><li>how to make contributions to it</li></ul><h3 id=__init__py>__init__.py</h3><p><code>__init__.py</code> tells Python that a directory can be imported as a package. It should contain these pieces of information:</p><ol><li>docstring that consists of an elevator page and some example usage</li><li>version number:
<code>major_number.minior_version.patch_level</code></li><li>import all the functions and classes from other sub-models or without additional code</li></ol><h3 id=tests>Tests</h3><p>Firstly, put tests in a separate directory to ensure they do not run in production. Tests are necessary, and it also serves as commendation. The tests directory mostly contains Python files, but it can also contain some auxiliary data.</p><h3 id=makefile>Makefile</h3><p>People tend to forget things like test steps. The best cure for this is automation. Once you write all the steps to run the tests in a script, documented and ready to execute. Makefile is a good tool to support task automation.</p><h3 id=setuppy>setup.py</h3><p><code>setup.py</code> is Python&rsquo;s way of defining a project. Firstly, we import <code>setup</code> function. Next, we read the description from the readme file and read requirements from <code>requirements.txt</code>. Finally, we call the setup function.</p><h2 id=dependency-management>Dependency Management</h2><h3 id=package-managers>Package managers</h3><p>Managing packages is not an easy task. Package managers like Pip, Poetry, Conda, Pipenv, and others will install third-party packages and their dependencies. For Pip, it always installs the latest version of a package, but installing a package with a specific version will help to reproduce the same environment in the future. Writing this in <code>requirements.txt</code> is useful.</p><h3 id=virtualenvs>virtualenvs</h3><p>A python interpreter can work with only one version of a package at a time. Creating a project-specific virtual environment to isolate the python installations is a good practice.</p><h3 id=production-vs-development>Production vs. Development</h3><p>The requirements used for production and development may be different. For example, production does not need packages for tests like Pytest. The common practice is to have separate requirements files, one(<code>requirements.ext</code>) for production and another one(<code>dev-requirements.txt</code>) for development. Another issue is that depending on the operating system. We might need different packages. The common practice here is to specify only top-level dependencies and let people decide what you need.</p><p>We can use <code>Makefile</code> to install packages for different requirements files. Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>env:
</span></span><span class=line><span class=cl>	# Create venv directory if not exist
</span></span><span class=line><span class=cl>	test -d venv || virtualenv venv
</span></span><span class=line><span class=cl>	./venv/bin/python -m pip install -r requirements.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dev-env: env
</span></span><span class=line><span class=cl>	./venv/bin/python -m pip install -r requirements-dev.txt
</span></span></code></pre></div><p>The <code>venv</code> rule says to create a virtual environment and to install only the requirements needed from production. The <code>dev-venv</code> rule relies on the <code>venv</code>, meaning it&rsquo;s going to execute first the <code>venv</code> rule and then add the development requirements</p><h2 id=testing>Testing</h2><h3 id=how-to-test>How to test</h3><p>Testing is important. It validates our code and guards us against breaking one part of the code when changing another. We have no time to implement all kinds of tests such as out-of-memory, crash, fuzz, regression, and much more. The common practice is to focus on the test that brings the most value. The following test types usually have the best deal:</p><ol><li>Integration, check the connection between subsystems and connection with external systems.</li><li>Regression, check if running code returns a known solution with known data.</li><li>Fuzzing, generating random data, and throwing it at the code.</li><li>Linters, are the static checkers that find common issues without running the tests.</li><li>Unit, check the code in isolation for valid output.
Finally, we should focus our effort on the tests that bring the most value based on the test result.</li></ol><p>We never have enough tests. Tests take time and effort to maintain. The major factor in how much test is the cost of error. The higher the cost, the more test we should write.</p><h3 id=pytest>Pytest</h3><p>A detailed guide can be found on the homepage of <code>pytest</code>.</p><h3 id=test-items>Test items</h3><h2 id=development-process>Development Process</h2><p>There is no true process; suitable is the best. There are several common practices, such as source control, issue tracking, feature branches, code review, and retrospective.</p><h3 id=source-control>Source control</h3><p>Git.</p><h3 id=issue-tracking>Issue tracking</h3><p>Every piece of work you do should be tracked. It can be a back fix, a feature to implement, or a maintenance task. The seven issue-tracking systems, such as Jira, Trello, Asana, and more. A good issue should have a good title and a good description. Using a template is a good choice.</p><h3 id=feature-branches>Feature branches</h3><p>A branch is a part of the development path on the same code base. A feature branch is a part development path that is dedicated to a specific feature or an issue. Once you start work on an issue, create a feature branch for it and work on this branch. A nice convention is to call the branch with the name of the feature.</p><h3 id=code-review>Code Review</h3><p>Code reviews are effective in decreasing bugs. It is also a great way to share knowledge.</p><h3 id=retrospective>Retrospective</h3><p>A retrospective, sometimes called postmortem, is a meeting you do at the end of a period or a sprint to discuss how you can improve. Retrospectives are very effective. Sadly, people tend to skip them, and they have a low priority in many teams. You should always allocate time for retrospectives. You can do retrospectives in a physical meeting or in an asynchronous way in a chat room or a shared document. I highly recommend documenting these retrospectives since they are common knowledge and represent organizational memory. Retrospectives can get long and tedious. Here&rsquo;s a template for making them short and effective. Everyone writes or talks about three things that went well, and we should keep three things that didn&rsquo;t go well and how to improve them. During the meeting, if there are things to do, known as action items, make sure to add them to your issue tracking and allocate time for them.</p><h2 id=conclusion>Conclusion</h2><p>Structure our code better, write down your dependencies, and write better tests. In time, we will find our code is of better quality.</p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://nicolgo.github.io/tags/python/>Python</a>
<a href=https://nicolgo.github.io/tags/software/>software</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=footer_slogan><span>Think big, Start small</span></div></footer><script src=https://nicolgo.github.io/js/jquery-3.5.1.min.js></script>
<link href=https://nicolgo.github.io/css/fancybox.min.css rel=stylesheet><script src=https://nicolgo.github.io/js/fancybox.min.js></script>
<script src=https://nicolgo.github.io/js/zozo.js></script>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['[[',']]']],processEscapes:!0,processEnvironments:!0,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=' has-jax'})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>